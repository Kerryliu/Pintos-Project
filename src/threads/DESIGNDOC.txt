pintos/src/threads/DESIGNDOC

			+--------------------+
			|       ECE 434      |
			| PROJECT 1: THREADS |
			|   DESIGN DOCUMENT  |
			+--------------------+
				   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

Kerry Liu <kl518@scarletmail.rutgers.edu>
Mehul Vora <mv363@scarletmail.rutgers.edu>
Sajeel Ahmad <netid@scarletmail.rutgers.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			     ALARM CLOCK
			     ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
timer.c:
- static struct list sleepingThreadList
	The list of threads that are currently blocked, in order of lowest
	to highest tick to be unblocked.  
thread.h:
- In struct thread:
	- wakeupTicks
		How long the thread will sleep for.  

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

- Timer sleep is given an argument "ticks".  This argument determines
how long the current thread will be blocked.  
- If the ticks given is zero or negative, then nothing happens, and 
the current therad continues to run.  
- If the ticks given is positive, then the thread is pushed to a list
of threads.  This list contains threads that are currently sleeping or
blocked, sorted from lowest to highest ticks.  

- Timer interrupt checks the first thread in the sleeping list to see 
if it is time to wake it up.  If it is, the thread is unblocked, and 
popped from the front of the sleeping list.  If not the thread will 
continue to be blocked.  

---- SYNCHRONIZATION ----

>> A3: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

Interrupts are disabled when timer_sleep is called, therefore 
there should not be multiple calls to timer_sleep, since pintos 
is a single core operating system.  This makes sure only one thread 
will be runnning at a time, and timer_sleep cannot be called 
simultaneously.

---- RATIONALE ----

>> A4: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

This design was chosen because it is very efficient and simple to 
implement.  It works well with multiple threads and eliminaes busy 
waiting.  It is superior to other algorithms that were considered since
it does not have to look at every thread's "wakeupticks" since they are 
inserted into the sleepingThreadList in the most optimal order. 

			 PRIORITY SCHEDULING
			 ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
thread.h:
- In struct thread: 
	-core_priority
		The assigned priority of the thread.  
	- requested_lock
		The lock that the thread is waiting on.  
	- donations
		The list of other threads waiting on the locks that the thread has.  
	- donations_elem
		list elements for the donations list.  

>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

A, B, and C are thread.  
L is a lock 

1) Lock holder A, Threads A & B are ready to run. C is on waitlist
A		B		C  <---Theads
1		2		3  <---Priority

2) Piority of A is changed to 3, so it can donate lock to C.  
A		B		C <---Threads
3		2		3 <---Priority

3) Now once the lock is passed to C, priority of A can be changed back.  
A		B		C <---Thread
1		2		3 <---Priority

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?
threads are inserted into a list sorted by priority.  Therefore popping 
the first element from the list will ensure that it is the highest 
priority.  

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

- The current thread's requested_lock is changed from NULL to the requested
lock.  
- The current thread is added to the current lock holder's donation list.  
- Priority is then donated via thread_donate_priority.  

---- SYNCHRONIZATION ----

>> B5: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.

Interrupts are turned off when setting priority.  This means that there 
cannot be a race in thread_set_priority().

---- RATIONALE ----

>> B6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?
>> Any other comments?
